#include "test_sequences.h"
using namespace ebu_list;
using namespace ebu_list::ptp;
using namespace ebu_list::ptp::v2::test;
using ebu_list::to_byte_array;

namespace data
{
    // from PTP_clock.pcap
    namespace two_step_sequence_1
    {
        constexpr auto sync_ts = clock::time_point(std::chrono::nanoseconds(1486566127'765647489));
        constexpr auto sync =
            to_byte_array(0x00, 0x02, 0x00, 0x2c, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x99, 0x3a, 0xff, 0xff, 0x26, 0x7e, 0x2b, 0x00, 0x14,
                          0xb3, 0xc3, 0x00, 0xfd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

        constexpr auto sync_with_timestamp_ts = clock::time_point(std::chrono::nanoseconds(1486566127'765647489));
        constexpr auto sync_with_timestamp =
            to_byte_array(0x00, 0x02, 0x00, 0x2c, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x99, 0x3a, 0xff, 0xff, 0x26, 0x7e, 0x2b, 0x00, 0x14,
                          0xb3, 0xc3, 0x00, 0xfd, 0x00, 0x00, 0x58, 0x9b, 0x33, 0x14, 0x39, 0xd8, 0x97, 0xbe);

        constexpr auto follow_up_ts = clock::time_point(std::chrono::nanoseconds(1486566127'770212129));
        constexpr auto follow_up =
            to_byte_array(0x08, 0x02, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x99, 0x3a, 0xff, 0xff, 0x26, 0x7e, 0x2b, 0x00, 0x14,
                          0xb3, 0xc3, 0x02, 0xfd, 0x00, 0x00, 0x58, 0x9b, 0x33, 0x14, 0x39, 0xd8, 0x97, 0xbe);

        constexpr auto delay_req_ts = clock::time_point(std::chrono::nanoseconds(1486566127'786199465));
        constexpr auto delay_req =
            to_byte_array(0x01, 0x02, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x70, 0xff, 0xfe, 0x00, 0x21, 0x86, 0x00, 0x01,
                          0x6d, 0x27, 0x01, 0x7f, 0x00, 0x00, 0x58, 0x9b, 0x33, 0x14, 0x39, 0xd8, 0x97, 0xc3);

        constexpr auto delay_resp_ts = clock::time_point(std::chrono::nanoseconds(1486566127'786703369));
        constexpr auto delay_resp    = to_byte_array(
               0x09, 0x02, 0x00, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
               0x00, 0x00, 0x28, 0x99, 0x3a, 0xff, 0xff, 0x26, 0x7e, 0x2b, 0x00, 0x14, 0x6d, 0x27, 0x03, 0xfd, 0x00, 0x00,
               0x58, 0x9b, 0x33, 0x14, 0x3b, 0x12, 0x2c, 0x61, 0x00, 0x23, 0x70, 0xff, 0xfe, 0x00, 0x21, 0x86, 0x00, 0x01);
    } // namespace two_step_sequence_1
} // namespace data

//------------------------------------------------------------------------------

ebu_list::ptp::v2::sync two_step_sequence_1::get_sync()
{
    auto pdu           = oview(make_static_sbuffer(data::two_step_sequence_1::sync));
    auto decode_result = decode(data::two_step_sequence_1::sync_ts, std::move(pdu));
    assert(decode_result);
    return std::get<v2::sync>(decode_result.value());
}

ebu_list::ptp::v2::sync two_step_sequence_1::get_sync_with_timestamp()
{
    auto pdu           = oview(make_static_sbuffer(data::two_step_sequence_1::sync_with_timestamp));
    auto decode_result = decode(data::two_step_sequence_1::sync_with_timestamp_ts, std::move(pdu));
    assert(decode_result);
    return std::get<v2::sync>(decode_result.value());
}

ebu_list::ptp::v2::follow_up two_step_sequence_1::get_follow_up()
{
    auto pdu           = oview(make_static_sbuffer(data::two_step_sequence_1::follow_up));
    auto decode_result = decode(data::two_step_sequence_1::follow_up_ts, std::move(pdu));
    assert(decode_result);
    return std::get<v2::follow_up>(decode_result.value());
}

ebu_list::ptp::v2::delay_req two_step_sequence_1::get_delay_req()
{
    auto pdu           = oview(make_static_sbuffer(data::two_step_sequence_1::delay_req));
    auto decode_result = decode(data::two_step_sequence_1::delay_req_ts, std::move(pdu));
    assert(decode_result);
    return std::get<v2::delay_req>(decode_result.value());
}

ebu_list::ptp::v2::delay_resp two_step_sequence_1::get_delay_resp()
{
    auto pdu           = oview(make_static_sbuffer(data::two_step_sequence_1::delay_resp));
    auto decode_result = decode(data::two_step_sequence_1::delay_resp_ts, std::move(pdu));
    assert(decode_result);
    return std::get<v2::delay_resp>(decode_result.value());
}
